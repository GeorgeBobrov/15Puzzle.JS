<!DOCTYPE html>
<html>
<head>
<style>
* {
  box-sizing: border-box;
}

body {
  margin: 0px;
  user-select: none;
}


.PanelClient {
  position: relative;
  width: 100%;
  height: 500px;
  margin: 0 auto;
  /*display: flex;
  flex-wrap: wrap;*/
  background-color: rgb(244, 244, 244);
}

.Tile {
  position: absolute;
  width: 50px;
  height: 50px;  
  font-size: 17px;
  text-align: center;
  line-height: 42px; 
  user-select: none;

  /*padding: 5px;*/  
  border: 4px solid #E55555;
  border-radius: 4px;
  background: linear-gradient(145deg, bisque 35%, #ABE024 90%);
  transition: .2s;

}
.PanelMenu {
  width: 500px;
  height: 50px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
  /*align-content: space-around; */ 
  background-color: rgb(228, 228, 228);  
}  

#TextTime {
  height: 70%;
  margin: 5px;
  padding: 0px 5px;
  background-color: rgb(244, 244, 244);
  border: 1px solid rgb(85, 123, 229);
}

.MenuButton {
  height: 70%;
  padding: 0px 5px;
  text-align: center;
  line-height: 70%;   
}

</style>
</head>
<body>

  <div class="PanelMenu">
    <div id="TextTime">TextTime</div>
    <button class="MenuButton ButtonShuffle" onclick="ButtonShuffleClick(this)">Shuffle</button> 
    <button class="MenuButton ButtonMenu" onclick="AnimateTimeRunningOut(this)">TimeRunningOut</button>
    <button class="MenuButton ButtonMenu" onclick="AnimateTimeOver(this)">TimeOver</button>
  </div>
  

<script>

let PanelClient = document.createElement('div');
document.body.appendChild(PanelClient);
PanelClient.classList.add('PanelClient');
window.onresize = PanelClientResize;


let TextTime = document.getElementById('TextTime');
// let TextTimeStyle = window.getComputedStyle(TextTime, null);
TextTime.style.lineHeight = (parseInt(TextTime.clientHeight)) + "px";
TextTime.style.fontSize = Math.trunc(parseInt(TextTime.offsetHeight) / 2) + "px";

let Tiles = [];
let TileSize;
let TileSpacing;
let SpaceX, SpaceY;
let Base = 4;

const TMode = Object.freeze({"Game":1, "GameOver":2, "JustShuffled":3, "PuzzleMatched":4});
let Mode;
            
let slowdown = 1.0;
const MaxMoveAniDuration = 150;
const MinMoveAniDuration = 1;
const TileFillNormalColor1 = 'bisque';
const TileFillNormalColor2 = '#ABE024';

let LastResizeTime = Date.now();
let TimeRemaining;

let TimerTime;
let TimerResize;


function CreateTiles( )
{


  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
      {
        let GradientAni = Tiles[i].getAttribute('TextNumber') ;
        delete GradientAni;

        Tiles[i].remove();
        Tiles[i] = undefined;
      }

  Tiles.length = (Base * Base);
  for ( let i = 0; i < Tiles.length - 1; i++)
  {
    if ( Tiles[i] == undefined )
    {
      let NewTile = document.createElement('div');

      NewTile.innerHTML = i + 1;
      NewTile.setAttribute('TextNumber', i);

      NewTile.classList.add('Tile');

      NewTile.onmousedown = function() {TileOnClick(this)};


      // let GradientAni = new TGradientAnimation(NewTile);
      // NewTile.setAttribute('GradientAni', GradientAni);


      PanelClient.appendChild(NewTile);
//      NewTile.SendToBack;
      Tiles[i] = NewTile;

    //   let GradientAni = Tiles[i].getAttribute('GradientAni') ;
    //   GradientAni.StartColor1 = TileFillNormalColor1;
    //   GradientAni.StartColor2 = TileFillNormalColor2;

    }

  }

  if ( Tiles[Tiles.length - 1] != undefined )
    Tiles[Tiles.length - 1] = undefined;
}

CreateTiles( );
AnimatePlaceTilesFast( );

function  SetMode( Value )
{
	Mode = Value;
	if ( Mode == TMode.Game )
		TimerTime = setInterval(TimerTimeTimer, 1000);
	else
    clearInterval(TimerTime)

}



function  ind( Row, Col )
{
    return Row * Base + Col;
}

function ActualPosition(ATile)
{
    for ( let i = 0; i < Tiles.length; i++)
        if (Tiles[i] == ATile)
            return i;
    return 0;
}

function TileOnClick(SenderTile) {
  // //let i = SenderTile.getAttribute('TextNumber');
  // //let top = Math.trunc(i/4) * 60;
  // let top = parseInt(SenderTile.style.top);
  // // SenderTile.style.top = (top+10) + "px";

  // SenderTile.style["top"] = (top+10) + "px";
	if ( Mode == TMode.JustShuffled )
		SetMode(TMode.Game);

  let WasMoved = TryMoveTile( ActualPosition(SenderTile), MaxMoveAniDuration, false );
	if ( WasMoved )
		CheckPuzzleMatched();
};

function  TryMoveTile( TilePosition, MoveAniDuration, WaitAnimationEnd )
{
  let WasMoved = false;

  let ColPressed = (TilePosition % Base);
  let RowPressed = Math.trunc(TilePosition / Base);


  for ( let Row = 0; Row < Base; Row++)
    if ( Tiles[ind( Row, ColPressed )] == undefined )
    {
      let RowNoTile = Row;
      if ( RowNoTile > RowPressed )
        for ( let RowToMove = RowNoTile - 1; RowToMove >= RowPressed; RowToMove--)
        {
          let NewPosition = ind( RowToMove + 1, ColPressed );
          Tiles[NewPosition] = Tiles[ind( RowToMove, ColPressed )];
          Tiles[ind( RowToMove, ColPressed )] = undefined;
          AnimateMoveTile( Tiles[NewPosition], MoveAniDuration, WaitAnimationEnd );
          WasMoved = true;
        }
      if ( RowPressed > RowNoTile )
        for ( let RowToMove = RowNoTile + 1; RowToMove <= RowPressed; RowToMove++)
        {
          let NewPosition = ind( RowToMove - 1, ColPressed );
          Tiles[NewPosition] = Tiles[ind( RowToMove, ColPressed )];
          Tiles[ind( RowToMove, ColPressed )] = undefined;
          AnimateMoveTile( Tiles[NewPosition], MoveAniDuration, WaitAnimationEnd );
          WasMoved = true;
        }
    }
  if ( ! WasMoved )
    for ( let Col = 0; Col < Base; Col++)
      if ( Tiles[ind( RowPressed, Col )] == undefined )
      {
        let ColNoTile = Col;
        if ( ColNoTile > ColPressed )
          for ( let ColToMove = ColNoTile - 1; ColToMove >= ColPressed; ColToMove--)
          {
            let NewPosition = ind( RowPressed, ColToMove + 1 );
            Tiles[NewPosition] = Tiles[ind( RowPressed, ColToMove )];
            Tiles[ind( RowPressed, ColToMove )] = undefined;
            AnimateMoveTile( Tiles[NewPosition], MoveAniDuration, WaitAnimationEnd );
            WasMoved = true;
          }
        if ( ColPressed > ColNoTile )
          for ( let ColToMove = ColNoTile + 1; ColToMove <= ColPressed; ColToMove++)
          {
            let NewPosition = ind( RowPressed, ColToMove - 1 );
            Tiles[NewPosition] = Tiles[ind( RowPressed, ColToMove )];
            Tiles[ind( RowPressed, ColToMove )] = undefined;
            AnimateMoveTile( Tiles[NewPosition], MoveAniDuration, WaitAnimationEnd );
            WasMoved = true;
          }
      }

  return WasMoved;
}


function  AnimateMoveTile( ATile, MoveAniDuration, WaitAnimationEnd )
{
  let ActPos = ActualPosition(ATile);
  let NewCol = (ActPos % Base);
  let NewRow = Math.trunc(ActPos / Base);

  let OffsetOnScaledTile = (TileSize - ATile.offsetWidth) / 2;
 

  let X = SpaceX + Math.round( NewCol * ( TileSize + TileSpacing ) + OffsetOnScaledTile);
  let Y = SpaceY + Math.round( NewRow * ( TileSize + TileSpacing ) + OffsetOnScaledTile);


  if ( MoveAniDuration > 0 )
  {
    AnimatePropertyDelay(ATile, "left", X, MoveAniDuration, 0, "OutExpo" );

    AnimatePropertyDelay(ATile, "top", Y, MoveAniDuration, 0, "OutExpo", true, WaitAnimationEnd );
  }
  else {
    ATile.style.left = X + "px";
    ATile.style.top = Y + "px";
  }
}

function CheckPuzzleMatched( )
{
	let LPuzzleMatched = true;
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			let TextNumber = Tiles[i].innerHTML;

			if ( (TextNumber - 1) != ActualPosition(Tiles[i]) )
			{
				LPuzzleMatched = false;
				break;
			}
		}

	if ( LPuzzleMatched && ( Mode == TMode.Game ) )
	{
		SetMode(TMode.PuzzleMatched);
		AnimatePuzzleMatched();
	}
	if ( ( ! LPuzzleMatched ) && ( ( Mode == TMode.PuzzleMatched ) || ( Mode == TMode.JustShuffled ) ) )
	{
		AnimateNormalizeTilesColor();
		if ( Mode == TMode.PuzzleMatched )
			SetMode(TMode.GameOver);
	}
}



function ButtonShuffleClick()
{
	AnimateNormalizeTilesColor();

	let NewI = 0;
	let MoveCount = Tiles.length * Tiles.length;
	let MoveAniDuration = MaxMoveAniDuration;
	for ( let i = 1; i <= MoveCount; i++)
	{
		if ( i <= 10 )
			MoveAniDuration = MinMoveAniDuration + ( MaxMoveAniDuration * ( 1 - (  i  / 10 ) ) );
		if ( i >= MoveCount - 10 )
			MoveAniDuration = MinMoveAniDuration + ( ( MaxMoveAniDuration / 2 ) * ( 1 - (  ( MoveCount - i )  / 10 ) ) );
		if ( ( i > 20 ) && ( i < MoveCount - 20 ) )
			if ( ( i % 10 ) == 0 )
				MoveAniDuration = MinMoveAniDuration;
			else
				MoveAniDuration = 0;
		do
		{
			NewI = Math.trunc(Math.random() * Tiles.length);
		}
		while ( ! ( TryMoveTile( NewI, MoveAniDuration, /*WaitAnimationEnd*/true ) ) );
	}
	SetMaxTime();
//  StopBlinkShuffle();

	SetMode(TMode.JustShuffled);
	CheckPuzzleMatched();
}


function TimerTimeTimer()
{
	TimeRemaining = TimeRemaining - 1;

  let Sec = (TimeRemaining % 60);
  let Min = Math.trunc(TimeRemaining / 60);

	TextTime.innerHTML = Min + ":" + String(Sec).padStart(2, '0');

	if ( TimeRemaining == 0 )
	{
		SetMode(TMode.GameOver);
		AnimateTimeOver();
//		StartBlinkShuffle();
		return;
	}
	if ( TimeRemaining <= 10 )
		AnimateTimeRunningOut();

}


function SetMaxTime( )
{
	TimeRemaining = Math.trunc( ( Base * Base * Base * Base ) / 20 ) * 10;

  let Sec = (TimeRemaining % 60);
  let Min = Math.trunc(TimeRemaining / 60);

	TextTime.innerHTML = Min + ":" + String(Sec).padStart(2, '0');
}


function PanelClientResize()
{
    clearTimeout(TimerResize);
		TimerResize = setTimeout(TimerResizeTimer, 200);
}



function TimerResizeTimer()
{
	// clearTimeout(TimerResize);
	let TimeFromLastResize_ms = Date.now() - LastResizeTime;

//	qDebug() << QString("TimerResizeTimer	") << QDateTime.currentDateTime().toString("mm:ss:zzz");

	if ( TimeFromLastResize_ms > 1000 )
	{
//			qDebug() << QString("AnimatePlaceTilesFast	") << TimeFromLastResize_ms;
    // PanelClient.style.width = window.width;
    let newHeight = parseInt(window.innerHeight) - 50;
    PanelClient.style.height = newHeight + "px";


		AnimatePlaceTilesFast();
		LastResizeTime = Date.now();
	}

}

function closeEvent(event)
{
	qDebug() << QString("closeEvent  ") << QDateTime.currentDateTime().toString("mm:ss:zzz");
	if ( ! ClosingAnimation )
	{
		AnimateTilesDisappeare();
		ClosingAnimation = true;
	}

}

//-------------------------------   Animations   -----------------------------

function CalcConsts( )
{
  let Height = parseInt(PanelClient.clientHeight);
  let Width = parseInt(PanelClient.clientWidth);

  if ( Height > Width )
  {
    SpaceX = Math.round( ( Width ) / 20 );
    TileSize = Math.round( ( ( Width - SpaceX * 2 ) ) / Base );
    SpaceY = SpaceX + Math.round( ( ( Height - Width ) ) / 2 );
  }
  else
  {
    SpaceY = Math.round( ( Height ) / 20 );
    TileSize = Math.round( ( ( Height - SpaceY * 2 ) ) / Base );
    SpaceX = SpaceY + Math.round( ( ( Width - Height ) ) / 2 );
  }
  TileSpacing = Math.round( TileSize * 0.06 );
  TileSize = Math.round( TileSize * 0.94 );
  SpaceX = SpaceX + Math.round( ( TileSpacing ) / 2 );
  SpaceY = SpaceY + Math.round( ( TileSpacing ) / 2 );
}



function AnimatePlaceTilesFast( )
{
  CalcConsts();
//  for (TRectangle CurTile : Tiles)
  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
    {

      let ScaleX = ( TileSize ) / Tiles[i].offsetWidth;
      let ScaleY = ( TileSize ) / Tiles[i].offsetHeight;

      let OffsetOnScaledTile = (TileSize - Tiles[i].offsetWidth) / 2;

      AnimatePropertyDelay( Tiles[i], "scaleX", ScaleX, 200 * slowdown, ( 200 + 30 * i ) * slowdown );
      // AnimatePropertyDelay( Tiles[i], "scaleY", ScaleY, 200 * slowdown, ( 100 + 30 * i ) * slowdown );

      let Col = (i % Base);
      let Row = Math.trunc(i / Base);

      let X = SpaceX + Math.round( Col * ( Tiles[i].offsetWidth * ScaleX + TileSpacing ) + OffsetOnScaledTile);
      let Y = SpaceY + Math.round( Row * ( Tiles[i].offsetHeight * ScaleY + TileSpacing ) + OffsetOnScaledTile);
      // Tiles[i].Tag = i;
      AnimatePropertyDelay( Tiles[i], "left", X, 200 * slowdown, ( 0 + 30 * i ) * slowdown );
      AnimatePropertyDelay( Tiles[i], "top", Y, 100 * slowdown, ( 0 + 30 * i ) * slowdown );
      /*, TAnimationType.atIn, TInterpolationType.Back*/

    }
}

function AnimateBaseNotChanged( )
{
  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
    {
      AnimatePropertyDelay( Tiles[i], "RotationAngle", - 20, 100 * slowdown, 0 * slowdown, TAnimationType.InOut, TInterpolationType.Linear );
      AnimatePropertyDelay( Tiles[i], "RotationAngle", 20, 250 * slowdown, 100 * slowdown, TAnimationType.InOut, TInterpolationType.Exponential );
      AnimatePropertyDelay( Tiles[i], "RotationAngle", 0, 250 * slowdown, 350 * slowdown, TAnimationType.Out, TInterpolationType.Back );
    }
}


function AnimateTilesDisappeare( )
{
  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
    {
      AnimatePropertyDelay( Tiles[i], "Scale.X", 100, 400 * slowdown, ( 30 * i ) * slowdown );
      AnimatePropertyDelay( Tiles[i], "Scale.Y", 100, 400 * slowdown, ( 30 * i ) * slowdown );
      AnimatePropertyDelay( Tiles[i], "RotationAngle", 45, 400 * slowdown, ( 30 * i ) * slowdown );
      AnimatePropertyDelay( Tiles[i], "Position.Y", Tiles[i].Position.Y + TileSize, 400 * slowdown, ( 30 * i ) * slowdown, TAnimationType.In, TInterpolationType.Back );
      AnimatePropertyDelay( Tiles[i], "Position.X", Tiles[i].Position.X + Round( double( TileSize ) / 2 ), 400 * slowdown, ( 30 * i ) * slowdown );
      AnimatePropertyDelay( Tiles[i], "Opacity", 0, 400 * slowdown, ( 100 + 30 * i ) * slowdown );
    }
}


function AnimatePrepareBeforePlace( )
{
  CalcConsts();
  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
    {
      let ScaleX = double( TileSize ) / Tiles[i].Width;
      let ScaleY = double( TileSize ) / Tiles[i].Height;


      let Col = (i % Base);
      let Row = Math.trunc(i / Base);
      
      let X = SpaceX + Round( Col * ( Tiles[i].Width * ScaleX + TileSpacing ) );
      let Y = SpaceY + Round( Row * ( Tiles[i].Height * ScaleY + TileSpacing ) );

      Tiles[i].Scale.X = 0.01;
      Tiles[i].Scale.Y = 0.01;
      Tiles[i].RotationAngle = 45;
      Tiles[i].Opacity = 0;
      Tiles[i].Position.X = X + Round( double( TileSize ) / 2 );
      Tiles[i].Position.Y = Y + TileSize;
    }
  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
    {
      Tiles[i].Position = Tile1.Position; //it is prettier
      AnimatePropertyDelay( Tiles[i], "Opacity", 1, 400 * slowdown, ( 100 + 30 * i ) * slowdown );
      AnimatePropertyDelay( Tiles[i], "RotationAngle", 0, 400 * slowdown, ( 30 * i ) * slowdown );
    }
}


function AnimateTimeRunningOut( )
{
  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
    {
      // let GradientAni = Tiles[i].getAttribute('GradientAni') ;
      let GradientAni = new TGradientAnimation(Tiles[i]);

      GradientAni.StopColor1 = TileFillNormalColor1;
      GradientAni.StopColor2 = "darkorange";
      GradientAni.Delay = 0;
      GradientAni.Duration = 150 * slowdown;
      GradientAni.AutoReverse = true;
      GradientAni.Start();
    }
}


function AnimateTimeOver( )
{
  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
    {
      // let GradientAni = Tiles[i].getAttribute('GradientAni') ;
      let GradientAni = new TGradientAnimation(Tiles[i]);

      GradientAni.Stop();
      GradientAni.StopColor1 = "gray";
      GradientAni.StopColor2 = "red";
      GradientAni.Delay = 0;
      GradientAni.Duration = 600 * slowdown;
      GradientAni.AutoReverse = false;
      GradientAni.Start();
    }
}


function AnimateNormalizeTilesColor( )
{
  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
    {
      // let GradientAni = Tiles[i].getAttribute('GradientAni') ;
      let GradientAni = new TGradientAnimation(Tiles[i]);

      GradientAni.StopColor1 = TileFillNormalColor1;
      GradientAni.StopColor2 = TileFillNormalColor2;
      GradientAni.Delay = 0;
      GradientAni.Duration = 200;
      GradientAni.AutoReverse = false;
      GradientAni.Start();
    }
}


function AnimatePuzzleMatched( )
{
  for ( let i = 0; i < Tiles.length; i++)
    if ( Tiles[i] != undefined )
    {
      AnimatePropertyDelay( Tiles[i], "RotationAngle", 360, 1 * slowdown, 350 * slowdown, TAnimationType.Out, TInterpolationType.Back );
      // let GradientAni = Tiles[i].getAttribute('GradientAni') ;
      let GradientAni = new TGradientAnimation(Tiles[i]);

      GradientAni.Stop();
      GradientAni.StopColor1 = "lawngreen";
      GradientAni.StopColor2 = "gold";
      GradientAni.Delay = ( 1000 + i * 100 ) * slowdown;
      GradientAni.Duration = 500 * slowdown;
      GradientAni.AutoReverse = false;
      GradientAni.Start();
    }
}


//console.log(Tiles);

function AnimatePropertyDelay(Target, PropertyName,
                  Value, Duration_ms, Delay_ms,
                 AInterpolation, DeleteWhenStopped, WaitAnimationEnd)
{
  let postfix = ""; 
  if ((PropertyName == "left") || (PropertyName == "top"))
  {
    postfix = "px";

    Target.style.transition = Duration_ms + "ms";

    Target.style[PropertyName] = Value + postfix;
  } else if (PropertyName == "scaleX") {
    Target.style["transform"] = "scale(" + Value + ")";
  }
}  

function TGradientAnimation( Target )
{
  this.Target = Target;
  this.StopColor1;
  this.StopColor2;
  this.Delay = 0;
  this.Duration = 200;
  this.AutoReverse = false;

  this.Start = function() {
    this.Target.style.transition = this.Duration + "ms";
    this.Target.style.background = 
    `linear-gradient(145deg, ${this.StopColor1} 35%, ${this.StopColor2} 90%)`;
  } ;
  this.Stop = function() {} ;


}

</script>



</body>
</html>