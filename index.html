<!DOCTYPE html>
<html>
<head>
<style>
* {
	box-sizing: border-box;
}

body {
	margin: 0px;
	user-select: none;
}


.PanelClient {
	position: relative;
	width: 33rem;
	height: 500px;
	margin: 0 auto;
	overflow: hidden;
	resize: both;
	/*display: flex;
	flex-wrap: wrap;*/
	background-color: rgb(244, 244, 244);
}

.Tile {
	position: absolute;
	width: 50px;
	height: 50px;  
	font-size: 17px;
	text-align: center;
	line-height: 42px; 
	user-select: none;

	/*padding: 5px;*/  
	border: 4px solid #E55555;
	border-radius: 4px;
	background: linear-gradient(145deg, bisque 35%, #ABE024 90%);
	transition: .2s;
}

.PanelMenu {
	width: 33rem;
	height: 3rem;
	margin: 0 auto;
	padding: 0.1rem 0.5rem;
	display: flex;
	justify-content: space-between;
	align-items: center;
	/*align-content: space-around; */ 
	background-color: rgb(228, 228, 228);  
}  

#TextTime {
	height: 100%;
	/*margin: 5px;*/
	padding: 0px 5px;
	background-color: rgb(244, 244, 244);
	border: 1px solid rgb(85, 123, 229);
}

.MenuButton {
	height: 100%;
	padding: 0px 5px;
	text-align: center;
	line-height: 100%;   
}

</style>

	<title>15Puzzle</title>
	<link rel="shortcut icon" type="image/vnd.microsoft.icon" href="./favicon.ico" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

	<div class="PanelMenu">
		<div id="TextTime">TextTime</div>
		<button class="MenuButton ButtonShuffle" onclick="ButtonShuffleClick(this)">Shuffle</button> 
		<button class="MenuButton" onclick="ChangeBaseClick(this)">3x3</button>
		<button class="MenuButton" onclick="ChangeBaseClick(this)">4x4</button>
		<button class="MenuButton" onclick="ChangeBaseClick(this)">5x5</button>    
	</div>
	<div class="PanelMenu">
		<button class="MenuButton" onclick="AnimateTilesDisappeare(this)">Disappeare</button>
		<button class="MenuButton" onclick="AnimatePrepareBeforePlace(this)">Prepare</button>    
		<button class="MenuButton" onclick="AnimatePlaceTilesFast(this)">Place</button>
		<button class="MenuButton" onclick="AnimatePrepPlaceTiles(this)">Prep+Place</button>   
	</div>
	<div class="PanelMenu">
		<button class="MenuButton" onclick="AnimateTimeRunningOut(this)">TimeRunningOut</button>
		<button class="MenuButton" onclick="AnimateTimeOver(this)">TimeOver</button>
		<button class="MenuButton" onclick="AnimatePuzzleMatched(this)">PuzzleMatched</button>
	</div>  

<script>

let PanelClient = document.createElement('div');
document.body.appendChild(PanelClient);
PanelClient.classList.add('PanelClient');

window.onresize = WindowResize;
function WindowResize() {
	let newHeight = parseInt(window.innerHeight) - 150;
	PanelClient.style.height = newHeight + "px";
};
WindowResize();

new ResizeObserver(PanelClientResize).observe(PanelClient);


let TextTime = document.getElementById('TextTime');
// let TextTimeStyle = window.getComputedStyle(TextTime, null);
TextTime.style.lineHeight = (parseInt(TextTime.clientHeight)) + "px";
TextTime.style.fontSize = Math.trunc(parseInt(TextTime.offsetHeight) / 2) + "px";

let Tiles = [];
let TileSize;
let TileSpacing;
let SpaceX, SpaceY;
let Base;

const TMode = Object.freeze({"Game":1, "GameOver":2, "JustShuffled":3, "PuzzleMatched":4});
let Mode;
						
let slowdown = 1.0;
const MaxMoveAniDuration = 150;
const MinMoveAniDuration = 1;
const TileFillNormalColor1 = 'bisque';
const TileFillNormalColor2 = '#ABE024';

const easeOutBack = 'cubic-bezier(0.175, 0.885, 0.32, 1.275)';
const easeInBack  =	'cubic-bezier(0.6, -0.28, 0.735, 0.045)';
const easeInOutBack	= 'cubic-bezier(0.68, -0.55, 0.265, 1.55)';
const easeOutExpo = 'cubic-bezier(0.19, 1, 0.22, 1)';
const easeInOutExpo = 'cubic-bezier(1, 0, 0, 1)';

let LastResizeTime = Date.now();
let TimeRemaining;

let TimerTime;
let TimerResize;


SetBase(4);

function ChangeBaseClick( Sender )
{
	let LBase = parseInt(Sender.innerHTML);
	SetBase(LBase);
}


async function SetBase(Value )
{
	if ( Value == Base )
	{
		AnimateBaseNotChanged();
		return;
	}
	SetMode(TMode.GameOver);
	await AnimateTilesDisappeare();

	Base = Value;
	SetMaxTime();

	setTimeout(TimerCreateTilesTimer, 10);
}

function TimerCreateTilesTimer( )
{
// #ifdef Q_OS_ANDROID
// 	on_ButtonScaleForAndroid_clicked();
// #endif

	CreateTiles();
	AnimatePrepareBeforePlace();
	
	setTimeout(AnimatePlaceTilesFast, 20); 
}


function CreateTiles( )
{
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
			{
				Tiles[i].remove();
				Tiles[i] = undefined;
			}

	Tiles.length = (Base * Base);
	for ( let i = 0; i < Tiles.length - 1; i++)
	{
		if ( Tiles[i] == undefined )
		{
			let NewTile = document.createElement('div');

			NewTile.innerHTML = i + 1;
			NewTile.setAttribute('TextNumber', i);

			NewTile.classList.add('Tile');

			NewTile.onmousedown  = function() {TileOnClick(this)};
			NewTile.ontouchstart = function(event) 
			{
				event.preventDefault(); 
				TileOnClick(this)
			};

			PanelClient.appendChild(NewTile);
//      NewTile.SendToBack;
			Tiles[i] = NewTile;
		}
	}

	if ( Tiles[Tiles.length - 1] != undefined )
		Tiles[Tiles.length - 1] = undefined;
}


function  SetMode( Value )
{
	Mode = Value;
	if ( Mode == TMode.Game )
		TimerTime = setInterval(TimerTimeTimer, 1000);
	else
		clearInterval(TimerTime)
}


function  ind( Row, Col )
{
	return Row * Base + Col;
}

function ActualPosition(ATile)
{
	for ( let i = 0; i < Tiles.length; i++)
		if (Tiles[i] == ATile)
			return i;
	return 0;
}

function TileOnClick(SenderTile) 
{
	if ( Mode == TMode.JustShuffled )
		SetMode(TMode.Game);

	let WasMoved = TryMoveTile( ActualPosition(SenderTile), MaxMoveAniDuration, false );
	if ( WasMoved )
		CheckPuzzleMatched();
};

async function  TryMoveTile( TilePosition, MoveAniDuration, WaitAnimationEnd )
{
	let WasMoved = false;

	let ColPressed = (TilePosition % Base);
	let RowPressed = Math.trunc(TilePosition / Base);

	for ( let Row = 0; Row < Base; Row++)
		if ( Tiles[ind( Row, ColPressed )] == undefined )
		{
			let RowNoTile = Row;
			if ( RowNoTile > RowPressed ) // Move tiles down
				for ( let RowToMove = RowNoTile - 1; RowToMove >= RowPressed; RowToMove--)
				{
					await MoveTile(ind( RowToMove, ColPressed ), ind( RowToMove + 1, ColPressed ), MoveAniDuration, WaitAnimationEnd);
					WasMoved = true;
				}
			if ( RowPressed > RowNoTile ) // Move tiles up
				for ( let RowToMove = RowNoTile + 1; RowToMove <= RowPressed; RowToMove++)
				{
					await MoveTile(ind( RowToMove, ColPressed ), ind( RowToMove - 1, ColPressed ), MoveAniDuration, WaitAnimationEnd);
					WasMoved = true;
				}
		}
	if ( ! WasMoved )
		for ( let Col = 0; Col < Base; Col++)
			if ( Tiles[ind( RowPressed, Col )] == undefined )
			{
				let ColNoTile = Col;
				if ( ColNoTile > ColPressed ) // Move tiles right
					for ( let ColToMove = ColNoTile - 1; ColToMove >= ColPressed; ColToMove--)
					{
						await MoveTile(ind( RowPressed, ColToMove ), ind( RowPressed, ColToMove + 1 ), MoveAniDuration, WaitAnimationEnd);
						WasMoved = true;
					}
				if ( ColPressed > ColNoTile ) // Move tiles left
					for ( let ColToMove = ColNoTile + 1; ColToMove <= ColPressed; ColToMove++)
					{
						await MoveTile(ind( RowPressed, ColToMove ), ind( RowPressed, ColToMove - 1 ), MoveAniDuration, WaitAnimationEnd);
						WasMoved = true;
					}
			}

	return WasMoved;
}

async function MoveTile( OldPosition, NewPosition, MoveAniDuration, WaitAnimationEnd )
{
	Tiles[NewPosition] = Tiles[OldPosition];
	Tiles[OldPosition] = undefined;
	if (WaitAnimationEnd)
		await AnimateMoveTile( Tiles[NewPosition], MoveAniDuration );
	else
		AnimateMoveTile( Tiles[NewPosition], MoveAniDuration );	
};


async function AnimateMoveTile( ATile, MoveAniDuration )
{
	let ActPos = ActualPosition(ATile);
	let NewCol = (ActPos % Base);
	let NewRow = Math.trunc(ActPos / Base);

	let OffsetOnScaledTile = (TileSize - ATile.offsetWidth) / 2;
 
	let X = SpaceX + Math.round( NewCol * ( TileSize + TileSpacing ) + OffsetOnScaledTile);
	let Y = SpaceY + Math.round( NewRow * ( TileSize + TileSpacing ) + OffsetOnScaledTile);

	ATile.style.transition = 
		`all 200ms linear 0ms,
		left ${MoveAniDuration}ms ${easeOutExpo} 0ms, 
		top ${MoveAniDuration}ms ${easeOutExpo} 0ms`; 

	return new Promise(function(resolve, reject) {

		if ( MoveAniDuration > 0 )
		{
			ATile.style.left = X + "px";
			ATile.style.top = Y + "px";   

			ATile.ontransitionend = function() {
				ATile.ontransitionend = undefined;
				resolve();
			};
		}
		else {
			ATile.style.left = X + "px";
			ATile.style.top = Y + "px";
			resolve();
		}

	});
}

function CheckPuzzleMatched( )
{
	let LPuzzleMatched = true;
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			let TextNumber = Tiles[i].innerHTML;

			if ( (TextNumber - 1) != ActualPosition(Tiles[i]) )
			{
				LPuzzleMatched = false;
				break;
			}
		}

	if ( LPuzzleMatched && ( Mode == TMode.Game ) )
	{
		SetMode(TMode.PuzzleMatched);
		AnimatePuzzleMatched();
	}
	if ( ( ! LPuzzleMatched ) && ( ( Mode == TMode.PuzzleMatched ) || ( Mode == TMode.JustShuffled ) ) )
	{
		AnimateNormalizeTilesColor();
		if ( Mode == TMode.PuzzleMatched )
			SetMode(TMode.GameOver);
	}
}



async function ButtonShuffleClick()
{
	AnimateNormalizeTilesColor();

	let NewI = 0;
	let MoveCount = Tiles.length * Tiles.length;
	let MoveAniDuration = MaxMoveAniDuration;
	for ( let i = 1; i <= MoveCount; i++)
	{
		if ( i <= 10 )
			MoveAniDuration = MinMoveAniDuration + Math.round( MaxMoveAniDuration * ( 1 - (  i  / 10 ) ) );
		if ( i >= MoveCount - 10 )
			MoveAniDuration = MinMoveAniDuration + Math.round( ( MaxMoveAniDuration / 2 ) * ( 1 - (  ( MoveCount - i )  / 10 ) ) );
		if ( ( i > 20 ) && ( i < MoveCount - 20 ) )
			if ( ( i % 10 ) == 0 )
				MoveAniDuration = MinMoveAniDuration;
			else
				MoveAniDuration = 0;
		
		let WasMoved;		
		do
		{
			NewI = Math.trunc(Math.random() * Tiles.length);
			WasMoved = await TryMoveTile( NewI, MoveAniDuration, /*WaitAnimationEnd*/true );
		}
		while ( ! WasMoved );

		// console.log(Date.now() + " Move "  + String(i).padStart(3, '0') + " Delay " +  MoveAniDuration);
	}
	SetMaxTime();
//  StopBlinkShuffle();

	SetMode(TMode.JustShuffled);
	CheckPuzzleMatched();
}


function TimerTimeTimer()
{
	TimeRemaining = TimeRemaining - 1;

	let Sec = (TimeRemaining % 60);
	let Min = Math.trunc(TimeRemaining / 60);

	TextTime.innerHTML = Min + ":" + String(Sec).padStart(2, '0');

	if ( TimeRemaining == 0 )
	{
		SetMode(TMode.GameOver);
		AnimateTimeOver();
//		StartBlinkShuffle();
		return;
	}
	if ( TimeRemaining <= 10 )
		AnimateTimeRunningOut();

}


function SetMaxTime( )
{
	TimeRemaining = Math.trunc( ( Base * Base * Base * Base ) / 20 ) * 10;

	let Sec = (TimeRemaining % 60);
	let Min = Math.trunc(TimeRemaining / 60);

	TextTime.innerHTML = Min + ":" + String(Sec).padStart(2, '0');
}


function PanelClientResize()
{
	clearTimeout(TimerResize);
	TimerResize = setTimeout(TimerResizeTimer, 200);
}



function TimerResizeTimer()
{
	let TimeFromLastResize_ms = Date.now() - LastResizeTime;

	if ( TimeFromLastResize_ms > 1000 )
	{
		AnimatePlaceTilesFast();
		LastResizeTime = Date.now();
	}

}


let ClosingAnimation = false;
window.onclose = closeEvent;
function closeEvent(event)
{
	if ( ! ClosingAnimation )
	{
		AnimateTilesDisappeare();
		ClosingAnimation = true;
	}
}

//-------------------------------   Animations   -----------------------------

function CalcConsts( )
{
	let Height = parseInt(PanelClient.clientHeight);
	let Width = parseInt(PanelClient.clientWidth);

	if ( Height > Width )
	{
		SpaceX = Math.round( ( Width ) / 20 );
		TileSize = Math.round( ( ( Width - SpaceX * 2 ) ) / Base );
		SpaceY = SpaceX + Math.round( ( ( Height - Width ) ) / 2 );
	}
	else
	{
		SpaceY = Math.round( ( Height ) / 20 );
		TileSize = Math.round( ( ( Height - SpaceY * 2 ) ) / Base );
		SpaceX = SpaceY + Math.round( ( ( Width - Height ) ) / 2 );
	}
	TileSpacing = Math.round( TileSize * 0.06 );
	TileSize = Math.round( TileSize * 0.94 );
	SpaceX = SpaceX + Math.round( ( TileSpacing ) / 2 );
	SpaceY = SpaceY + Math.round( ( TileSpacing ) / 2 );
}

let ScaleSettings;

function AnimatePlaceTilesFast( )
{
	CalcConsts();

	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			let ScaleX = ( TileSize ) / Tiles[i].offsetWidth;
			let ScaleY = ( TileSize ) / Tiles[i].offsetHeight;

			let OffsetOnScaledTile = (TileSize - Tiles[i].offsetWidth) / 2;

			let dl = 30 * i; //delay for tile

			Tiles[i].style.transition = `all 200ms linear 0ms,
				transform 200ms linear ${100 + dl}ms, 
				left 200ms linear ${dl}ms, 
				top 100ms linear ${dl}ms, 
				opacity 400ms linear ${100 + dl}ms`;

			ScaleSettings = "scale(" + ScaleX + ")";
			Tiles[i].style.transform = ScaleSettings;

			let Col = (i % Base);
			let Row = Math.trunc(i / Base);

			let X = SpaceX + Math.round( Col * ( Tiles[i].offsetWidth * ScaleX + TileSpacing ) + OffsetOnScaledTile);
			let Y = SpaceY + Math.round( Row * ( Tiles[i].offsetHeight * ScaleY + TileSpacing ) + OffsetOnScaledTile);

			Tiles[i].style.left = X + "px";
			Tiles[i].style.top = Y + "px";   
		}
}


function AnimateBaseNotChanged( )
{
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			let Tile = Tiles[i];

			Tile.style.transition = `transform 100ms linear 0ms`;
			Tile.style.transform = ScaleSettings + " rotate(-20deg)";
			setTimeout(function() 
			{
				Tile.style.transition = `transform 250ms ${easeInOutExpo} 0ms`;
				Tile.style.transform = ScaleSettings + " rotate(20deg)";
				setTimeout(function() 
				{
					Tile.style.transition = `transform 250ms ${easeOutBack} 0ms`;
					Tile.style.transform = ScaleSettings;
				} , 250);        
			} , 100);
		}
}


async function AnimateTilesDisappeare( )
{
	let LastTile;
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			let dl = 30 * i; //delay for tile

			Tiles[i].style.transition = `all 200ms linear 0ms,
				transform 400ms linear ${dl}ms, 
				left 400ms linear ${dl}ms, 
				top 400ms ${easeInBack} ${dl}ms, 
				opacity 400ms linear ${100 + dl}ms`;
				
			Tiles[i].style.transform = "scale(0.1) rotate(45deg)";

			Tiles[i].style.opacity = 0;

			let OffsetOnScaledTile = (TileSize - Tiles[i].offsetWidth) / 2;

			let CurX = parseInt(Tiles[i].style.left) - OffsetOnScaledTile;
			let CurY = parseInt(Tiles[i].style.top) - OffsetOnScaledTile;
			Tiles[i].style.left = Math.round(CurX + ( ( TileSize ) / 2 )) + "px";
			Tiles[i].style.top = Math.round(CurY + TileSize) + "px";

			LastTile = Tiles[i];
		}

	return new Promise(function(resolve, reject) 
	{
		if ( LastTile != undefined )
		{
			LastTile.ontransitionend = function() 
			{
				LastTile.ontransitionend = undefined;
				resolve();
			}
		} else
			resolve();
	});

}


function AnimatePrepareBeforePlace( )
{
	CalcConsts();
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			let ScaleX = ( TileSize ) / Tiles[i].offsetWidth;
			let ScaleY = ( TileSize ) / Tiles[i].offsetHeight;

			let Col = (i % Base);
			let Row = Math.trunc(i / Base);
			
			let X = SpaceX + Math.round( Col * ( Tiles[i].offsetWidth * ScaleX + TileSpacing ) );
			let Y = SpaceY + Math.round( Row * ( Tiles[i].offsetHeight * ScaleY + TileSpacing ) );

			Tiles[i].style.transition = "0ms";
			Tiles[i].style.transform = "scale(0.01) rotate(45deg)";

			Tiles[i].style.opacity = 0;
			Tiles[i].style.left = (X + Math.round( ( TileSize ) / 2 )) + "px";
			Tiles[i].style.top = (Y + TileSize) + "px";
		}

	setTimeout(function() 
	{  
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			let dl = 30 * i; //delay for tile

			Tiles[i].style.transition = `all 200ms linear 0ms,
				transform 200ms linear ${dl}ms, 
				left 200ms linear ${dl}ms, 
				top 100ms linear ${dl}ms, 
				opacity 400ms linear ${100 + dl}ms`;

			Tiles[i].style.transform = "rotate(45deg)";
			Tiles[i].style.opacity = 1;

		}
	}, 20);
}


function AnimateTimeRunningOut( )
{
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			Tiles[i].style.transition = "150ms";
			Tiles[i].style.boxShadow = "0 -30px 20px -12px darkorange inset"; 

			let Tile = Tiles[i];
			setTimeout(function() {
				Tile.style.boxShadow = ""; 
			} , 150);

		}
}


function AnimateTimeOver( )
{
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			Tiles[i].style.transition = "600ms";
			Tiles[i].style.boxShadow = "0 -200px 10px -12px red inset"; 

			let Tile = Tiles[i];
			setTimeout(function() {
				Tile.style.background = "linear-gradient(145deg, gray 35%, red 90%)";
				Tile.style.boxShadow = ""; 
			} , 300 + 30 * i);

		}
}


function AnimateNormalizeTilesColor( )
{
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			Tiles[i].style.transition = "200ms";
			Tiles[i].style.background = `linear-gradient(145deg, ${TileFillNormalColor1} 35%, ${TileFillNormalColor2} 90%)`;
		}
}


function AnimatePuzzleMatched( )
{
	for ( let i = 0; i < Tiles.length; i++)
		if ( Tiles[i] != undefined )
		{
			Tiles[i].style.transition = `all 200ms linear 0ms,
				transform 1000ms ${easeOutBack} 350ms`;
			Tiles[i].style.transform = ScaleSettings + " rotate(360deg)";

			let Tile = Tiles[i];
			setTimeout(function() {
				Tile.style.background = "linear-gradient(145deg, lawngreen 35%, gold 90%)";
			} , 300 + 30 * i);

		}
}

function AnimatePrepPlaceTiles()
{
	AnimatePrepareBeforePlace();
	setTimeout(AnimatePlaceTilesFast, 20);
	// console.log("Tile " + String(i).padStart(2, '0') + " Prepr3 " + Date.now() );
}


</script>


</body>
</html>